#pragma once


#define VK_USE_PLATFORM_WIN32_KHR
#include <vulkan/vulkan.h>

#include "../Dependencies/Eos/Eos/Eos.h"
#include "../Dependencies/Nix/Nix/Nix.h"

#include "RenderCommon.h"

#include "../Material/Material.h"

#include "../Core/CoreDefs.h"

#include "../Texture/Texture.h"

#include "../Geometry/Frustum.h"
//#include "RenderDefs.h"


#define ION_MAX_RENDER_COMMAND  16


EOS_USING_NAMESPACE
NIX_USING_NAMESPACE


ION_NAMESPACE_BEGIN

///

enum ERenderOperation 
{
    ERenderOperation_None = 0,
    ERenderOperation_Draw_View,
    ERenderOperation_Copy_Render,
};

///
///



struct DrawSurface final
{
	ionSize             m_indexCount;
	VertexCacheHandler  m_vertexCache;
	VertexCacheHandler  m_indexCache;
	VertexCacheHandler  m_jointCache;
	ionU64				m_extraGLState;
	//const viewEntity_t*	m_space;
	const Material*     m_material;

	DrawSurface()
	{
		m_indexCount = 0;
		m_vertexCache = 0;
		m_indexCache = 0;
		m_jointCache = 0;
		m_extraGLState = 0;
		m_material = nullptr;
	}
};


// generated by nodes
struct RenderView final 
{
	ionFloat			m_degFov;
	Vector				m_position;
	Matrix				m_matrix;			// matrix transform for any nodes, view (straigth or inverse) for the camera

	RenderView() : m_degFov(110)
	{}
};


//class SceneGraph; // -> idRenderWorld?

struct ViewDefinition final
{
	RenderView				m_renderView;

	ionFloat				m_shaderProjectionMatrix[16];
	Matrix					m_renderProjectionMatrix;
	//viewEntity_t			worldSpace;

	//idRenderWorld*		renderWorld;

	Vector					m_clipPlaneNormal;
	ionFloat				m_clipPlaneDistances;

	VkViewport				m_viewport;
	VkRect2D				m_scissor;


	ViewDefinition*			m_superView;
	const DrawSurface*		m_subviewSurface;

	// drawSurfs are the visible surfaces of the viewEntities, sorted by the material sort parameter
	eosVector(DrawSurface*)	m_drawSurfs;

	//viewEntity_t *			m_viewEntitys;

	Frustum::Planes			m_frustumPlanes;		
};

struct RenderCommand final
{
    ERenderOperation	m_operation;
    Texture*	        m_texture;
	ViewDefinition*	    m_viewDef;
    ionS32			    m_x;
    ionS32			    m_y;
    ionS32			    m_textureWidth;
    ionS32			    m_textureHeight;
    ionS32			    m_cubeFace;			// when copying to a cubeMap
    ionBool		        m_clearColorAfterCopy;

    RenderCommand() :
        m_operation(ERenderOperation_None),
        m_texture(nullptr),
        m_viewDef(nullptr),
        m_x(0),
        m_y(0),
        m_textureWidth(0),
        m_textureHeight(0),
        m_cubeFace(0),
        m_clearColorAfterCopy(false) {}
};


class FrameData final
{
private:
    typedef std::atomic_size_t   AtomicSize;

public:
    FrameData() :
        m_frameMemory(nullptr),
        m_renderCommandIndex(0)
    {
        m_frameMemoryAllocated.fetch_add(0, std::memory_order_relaxed);
        m_frameMemoryUsed.fetch_add(0, std::memory_order_relaxed);
        m_renderCommands.resize(ION_MAX_RENDER_COMMAND, RenderCommand());
    }

    AtomicSize	                m_frameMemoryAllocated;
    AtomicSize	                m_frameMemoryUsed;
    ionU8*					    m_frameMemory;
    ionS32						m_renderCommandIndex;
    eosVector(RenderCommand)    m_renderCommands;       // 16 max
};

ION_NAMESPACE_END